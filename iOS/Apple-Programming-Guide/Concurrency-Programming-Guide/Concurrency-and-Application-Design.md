# Concurrency Programming Guide

동시성 프로그래밍 가이드

원문: [Concurrency Programming Guide](https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/Introduction/Introduction.html)

## 동시성과 앱 설계

컴퓨팅의 역사 속에서 타임 유닛 당 컴퓨터가 처리할 수 있는 일의 양은 CPU의 클락 스피드에 의해 결정되어 왔다. 그러나 기술이 발전되고 프로세서 설계가 더 소형화되면서 열과 물리적인 제약 조건들이 프로세서의 최대 클락 스피드에 영향을 주기 시작했다. 그래서 칩 제조업자들은 그들의 칩 성능을 올려 줄 다른 방법들을 찾기 시작했다. 그들이 정착한 솔루션은 칩의 프로세스 코어 갯수를 증가시키는 것이었다. 코어 수를 올림으로써 CPU 스피드의 증가나 칩 사이즈, 온도 특성 변화 없이 한 개의 칩은 초당 더 많은 명령어들을 수행할 수 있게 되었다. 유일한 문제는 어떻게 남는 코어들로부터 이득을 취하는가이다.

멀티 코어의 이점을 누리기 위해서는 컴퓨터는 동시에 여러 가지를 수행하는 소프트웨어가 필요하다. OS X나 iOS 같은 멀티 태스킹 운영 체제에서는 수 백개 이상의 프로그램이 특정 시간대에 돌아갈 수 있다. 그래서 각각의 프로그램들을 다른 코어에서 동작하도록 하는 스케줄링이 가능해야 한다. 그러나 이러한 많은 프로그램들은 아주 작은 프로세싱 타임을 소비하는 시스템 데몬이거나 백그라운드 앱이다. 그래서 정말로 필요한 것은 각각의 앱들이 여분의 코어들을 더 효과적으로 사용할 수 있는 방법이다. 

멀티 코어를 사용하는 앱들이 사용하던 전통적인 방법은 여러 개의 스레드를 생성하는 것이었다. 그러나 코어 수가 증가하면서 스레드를 이용한 방법들에 문제가 생겼다. 가장 큰 문제점은 스레드화 된 코드가 코어 수에 맞게 확장되지 않는다는 점이다. 코어가 있는 만큼 스레드를 생성할 수 없으며, 프로그램이 잘 동작할 수 있을 것이라고 예상할 수 없다. 알아야 할 것은 효율적으로 사용할 수 있는 코어의 수이다. 앱이 스스로 그것을 계산하는 것은 굉장히 어려운 일이다. 만약 그 수를 알아내더라도, 많은 스레드를 프로그래밍하고, 효과적으로 실행되게 하고, 서로 영향을 주지 않게 하는 것은 어렵다.

문제를 요약하자면, 앱이 여러 개의 컴퓨터 코어를 이용해 이점을 얻을 수 있게 하는 방법이 필요하다. 또한 하나의 앱에서 실행되어야 할 일의 양은 시스템 컨디션에 적합하게 동적으로 계산되어야 할 필요가 있다. 그리고 솔루션은 멀티 코어를 통한 이점을 얻기 위해 수행되어야 할 일의 양을 늘리지 않도록 간단해야 한다. 좋은 소식은 애플의 운영 체제는 이러한 문제에 대한 솔루션을 제공하고 있다는 것이다. 이 장에서는 이 솔루션을 구성하는 기술과 코드를 더 효율적으로 하는 설계 변경을 소개한다.



### 스레드로부터 멀어지기 

스레드가 한참 동안 사용되어 왔고 지금도 계속 사용되고 있지만, 여러 작업들을 확장성있게 수행할 수 없다는 문제를 해결하지 못했다. 스레드를 사용하면 확장 가능한 솔루션을 만들어야 한다는 부담이 개발자들의 어깨에 놓여지게 된다. 개발자들은 몇 개의 스레드를 생성할지, 시스템 컨디션에 따라 수를 동적으로 조정할지를 결정해야 한다. 또 다른 문제점은 앱이 스레드를 생성하고 유지하는 데에 많은 비용을 소모한다는 점이다.

스레드에 의존하는 대신, OS X와 iOS는 비동기적 설계 방식을 동시성 문제를 해결하기 위해 사용한다. 비동기 함수는 오랜 시간 동안 운영 체제에 존재했던 기능으로 데이터를 디스크에서 읽어 오는 등의 긴 시간을 요구하는 작업들을 시작하기 위해 사용되어 왔다. 비동기 함수는 호출되면, 씬의 뒤에서 작업이 시작되도록 하는 일을 하고, 작업이 실제로 완료되기 전에 반환한다. 보편적으로, 이 일은 백그라운드 스레드와 관련이 있고, 요구되는 작업을 그 스레드에서 시작한다. 그리고 caller에게 작업이 완료되었을 때 알림을 보낸다. (보통 callback 함수를 이용하여 알림을 보낸다.) 과거에는, 비동기 함수가 원하는 일을 하기 위해 존재하지 않거나, 비동기 함수를 직접 작성해야 하거나, 스레드를 직접 생성해야 했다. 하지만 지금은 OS X와 iOS가 어떤 작업이든 스레드 관리 없이 비동기적으로 수행할 수 있도록 해주는 기술을 제공한다.

비동기적으로 작업을 수행할 수 있게 해 주는 기술 중 하나는 **Grand Central Dispatch** (GCD)이다. 이 기술은 일반적으로 앱에서 작성했을 스레드 관리 코드를 시스템 레벨로 보낸다. 해야할 것은 실행시키길 원하는 작업들을 정의하고, 그것을 적절한 dispatch queue에 추가하는 것이다. GCD가 필요한 스레드를 생성하고, 스레드에서 작업들을 스케줄링하는 것을 담당한다. 이제 스레드 관리는 시스템의 일부이기 때문에, GCD는 작업 관리와 실행, 스레드를 이용할 때보다 더 효율성을 제공하는 것과 관련된 종합적인 방법을 제공한다. 

**Operation Queue** 는 Objective-C 객체로 dispatch queue와 비슷하게 동작한다. 실행시키길 원하는 작업들을 정의하고 그것들을 작업들의 스케줄링과 실행을 관리할 operation queue에 추가한다. GCD처럼, operation queue는 스레드 관리와 관련된 모든 것들을 제어하고, 작업들이 가능한 빠르고 효율적으로 시스템 위에서 동작할 것을 보장한다.

앞으로의 섹션에서 dispatch queue, operation queue, 그리고 앱에서 사용할 수 있는 다른 비동기 기술들에 대해 소개한다.



#### Dispatch Queues

dispatch queue는 커스텀 작업들을 실행시키기 위한 C 기반의 메커니즘이다. dispatch queue는 작업들을 연속적으로 또는 동시에 실행시킬 수 있지만 first-in, first-out의 순서를 따른다. (다른 말로 표현하자면 queue에 추가된 순서대로 작업이 시작된다.) serial dispatch queue는 한 번에 오직 하나의 작업만 수행하고, 다른 작업이 완료되기 전까지 dequeue하거나 새로운 작업을 시작하는 것을 하지 않고 기다린다. 반대로, concurrent dispatch queue는 가능한 많은 작업들을 이미 시작된 작업이 완료되길 기다리지 않고 시작한다.

dispatch queue는 다음과 같은 이점을 가진다.

* 직접적이고 간단한 프로그래밍 인터페이스를 제공한다.
* 자동적인 그리고 전체적인 스레드 풀 관리를 제공한다.
* tuned assembly에 대한 속도를 제공한다.
* 메모리 관점에서 더 효과적이다. (스레드 스택은 더 이상 앱 메모리에 있지 않다.)
* 로드중인 커널에 트랩되지 않는다.
* dispatch queue에 작업을 비동기적으로 보내는 것은 queue에 데드락을 발생시키지 않는다.
* 우아하게 확장한다. (문맥 상 시스템 컨디션에 맞게 동적으로 스케일을 조정한다는 뜻인 듯하다.)
* serial dispatch queue는 lock과 다른 동기화 기본 요소들의 더 효과적인 대안이 된다.

dispatch queue에 추가한 작업들은 함수나 block 객체의 내부에 캡슐화된다. block 객체는 OS X v10.6, iOS 4.0에 도입된 C언어 기능으로 함수 포인터와 개념적으로 유사하나 추가 이점들이 존재한다. 자체 lexical scope에서 block을 정의하는 대신, 다른 함수나 메서드에서 정의함으로써 함수나 메서드의 다른 변수들에 접근할 수 있다. block은 자신의 원래 범위를 벗어나 힙에 복사될 수 있고, 이는 dispatch queue에 block을 제출할 때 발생한다. 이 모든 semantics를 통해 비교적 적은 코드로 동적인 작업들을 실현할 수 있다.

dispatch queue는 Grand Central Dispatch 기술의 일부이며 C 런타임의 일부이다. dispatch queue의 더 많은 쓰임에 대해 알고 싶다면 [Dispatch Queues](https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationQueues/OperationQueues.html#//apple_ref/doc/uid/TP40008091-CH102-SW1)를 읽어라. block과 그 장점들에 대해 더 많이 알고 싶다면, [Blocks Programming Topics](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Blocks/Articles/00_Introduction.html#//apple_ref/doc/uid/TP40007502)를 봐라.



#### Dispatch Sources

dispatch source는 특정 타입의 시스템 이벤트를 비동기적으로 처리하기 위한 C 기반의 메커니즘이다. dispatch source는 특정 타입의 시스템 이벤트에 대한 정보를 캡슐화하고 특정 block 객체 또는 함수를 dispatch queue에 해당 이벤트가 발생할 때마다 제출한다. dispatch source를 아래의 시스템 이벤트들이 발생할 때 사용할 수 있다.

* 타이머
* 시그널 핸들러
* descriptor와 관련된 이벤트
* 프로세스와 관련된 이벤트
* 프로세스와 관련된 이벤트
* 마하 포트 이벤트
* 마하 포트 이벤트
* 트리거 된 커스텀 이벤트

dispatch source는 Grand Central Dispatch 기술의 일부입니다. dispatch source를 이용해 이벤트를 받는 것에 대해 더 많이 알고 싶다면, [Dispatch Sources](https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/GCDWorkQueues/GCDWorkQueues.html#//apple_ref/doc/uid/TP40008091-CH103-SW1) 를 봐라.



#### Operation Queues

operation queue는 concurrent dispatch queue와 동일한 Cocoa이며, `NSOperationQueue` 클래스에 의해 구현된다. dispatch queue는 항상 first-in, first-out 순서로 실행되는 데 반해, operation queue는 작업의 실행 순서를 결정할 때 다른 요소들을 고려한다. 이러한 요소 중 가장 주요한 것은 주어진 작업이 다른 작업의 완료에 영향을 받는지 여부이다. 작업을 정의할 때 종속성을 설정하고 작업들의 복잡한 실행 순서 그래프를 만드는 데 이를 이용할 수 있다.

operation queue로 제출한 작업은 반드시 `NSOperation` class의 인스턴스여야 한다. operation object는 Objective-C 객체로 실행시키고 싶은 일과 수행하고 싶은 데이터를 캡슐화한다. `NSOperation` 클래스는 기본적으로 추상 기반 클래스로, 작업을 수행하기 위해서 보통 커스텀 서브 클래스를 만든다. Foundation 프레임워크에는 작업을 수행하기 위해 만들고 사용할 수 있는 concrete subclass가 포함되어 있다.

operation 객체는 작업의 진행 상황을 모니터링하기 좋은 key-value observing (KVO) 알림을 생성한다. operation queue가 항상 operation을 동시에 실행하지만, 작업이 필요할 때 연속적으로 실행되는 것을 보장하도록 종속성을 사용할 수도 있다. 

operation queue를 어떻게 사용하는지, 어떻게 커스텀 operation 객체를 정의하는지 더 알아보고 싶다면, [Operation Queues](https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationObjects/OperationObjects.html#//apple_ref/doc/uid/TP40008091-CH101-SW1) 를 봐라. 



### 비동기 설계 테크닉

코드를 동시성을 지원하도록 재설계하는 것을 고려하기 전에, 이것이 정말로 필요한 일인지 스스로에게 물어야 한다. 메인 스레드가 자유롭고 유저 이벤트에 응답함을 보장하는 것을 바탕으로 동시성은 코드의 응답성을 높일 수 있다. 또한 같은 양의 시간 동안 코어들이 더 많은 일을 하기 때문에 코드의 효율성을 향상시킬 수 있다. 그렇지만 이것 또한 오버헤드와 전체적인 코드의 복잡도를 증가시키고 디버깅을 힘들게 할 수도 있다.

복잡성이 추가되기 때문에 동시성은 개발의 마지막 단계에 추가할 수 있는 기능이 아니다. 제대로 적용하기 위해서는 앱이 수행할 작업과 작업들을 수행하기 위해 필요한 자료 구조에 대한 신중한 고려가 필요하다. 제대로 적용되지 않는다면 이전보다 느리고 유저에게 응답성이 낮아지는 경우가 생길 수 있다. 그러므로 설계 사이클의 시작 단계에서 목표를 정하고 취해야 할 접근법을 선택하는 시간을 가지는 것이 필요하다. 

모든 앱은 각각 다른 요구사항과 각각 다른 수행해야 할 작업들을 가진다. 단 하나의 문서만으로 어떻게 앱과 그와 관련된 작업들을 설계할 지 정확히 말하는 것은 불가능하다. 그렇지만 다음 섹션들에서 설계 프로세스에서 좋은 선택들을 내릴 수 있게 도움을 줄 가이드를 제공하려 노력할 것이다.



#### 앱의 기대되는 행동을 정의하라

앱에 동시성을 추가하는 것을 생각해보기 전에, 항상 앱의 적절한 행동으로 생각되는 것을 정의하는 것으로 시작해야 한다. 앱의 기대되는 행동들을 이해하면 설계를 검증할 수 있다. 또한 동시성을 도입함으로써 기대되는 성능 이점에 대한 아이디어도 얻을 수 있다.

가장 처음 해야 할 일은 앱이 수행해야 할 작업과 각각의 작업들과 관련된 객체나 자료 구조를 열거하는 것이다. 초기에 유저가 메뉴 아이템을 선택하거나 버튼을 클릭하는 것으로 수행할 작업을 시작하고 싶을 수 있다. 이런 작업은 개별 행위를 제공하며 시작과 끝이 잘 정의되어 있다. 또한 타이머 기반의 작업과 같은 유저 인터랙션이 없는 다른 작업들도 열거해야 한다.

고수준 작업들에 대한 리스트를 만든 다음에, 각각의 작업들을 성공적으로 수행할 수 있는 작은 단위로 세분화하라. 이 단계에서 자료 구조나 객체들의 변경과 그 변경 사항이 앱의 전체 상태에 어떤 영향을 미칠 지에 대해 고려해야 한다. 또한 객체들과 자료 구조들 간에 있는 종속성에 대해서도 유의해야 한다. 예를 들어 어떤 작업이 객체의 배열에 대해 동일한 변경을 만든다면, 한 객체의 변경 사항이 다른 객체들에게 영향을 주는 지 여부를 주목할 필요가 있다. 각각의 객체가 독립적인 변경을 만든다면, 동시성으로 변경을 만들기에 적합한 지점일 수 있다.



#### 실행 가능한 일의 단위를 뽑아내라

앱의 작업들을 이해하는 것에서부터 어디에서 동시성의 이점을 얻을 수 있는지 알게 된다. 만약 순서가 변경되는 것이 결과에 영향을 미친다면, 그 단계들을 연속적으로(serially) 수행해야 한다. 순서를 변경하는 것이 결과에 영향을 주지 않다면, 동시에 수행하는 것을 고려해보아야 한다. 두 가지 케이스 모두에서 수행할 단계를 나타내는 실행 가능한 일의 단위를 정의한다. 이 일의 단위는 block이나 operation으로 캡슐화되어 적절한 큐에 보내지게 된다.

각각의 실행 가능한 일의 단위는 초기에는 수행되어야 할 일의 갯수에 대해 너무 많은 걱정을 하지 마라. 스레드를 스핀 업하는 데는 항상 비용이 들지만, dispatch queue와 operation queue의 장점 중 하나는 많은 경우에 전통적인 스레드를 이용한 방식을 이용할 때보다 적은 비용이 든다는 것이다. 그러므로 스레드를 이용할 때보다 더 작은 일의 단위들을 큐를 이용해 효율적으로 실행하는 것이 가능해진다. 물론 항상 실제 성능을 측정해야 하고, 작업의 크기를 최적화 시켜야 한다. 하지만 초기에는 작업의 단위가 아주 작을 필요는 없다.



#### 필요한 큐를 식별하라

이제 작업들은 구별되는 일의 단위로 분해됐고, block이나 operaation 객체로 캡슐화되었다. 이제 코드를 실행시킬 큐를 정의해야 한다. 주어진 작업에 대해서 생성된 block이나 operation 객체와 그 순서가 실행되기 적절한 지 검사해야 한다. 

작업을 block을 이용해서 구현했다면, block을 serial 이나 concurrent dispatch queue 모두에 추가할 수 있다. 특별한 순서가 요구된다면, 항상 serial dispatch queue에 추가해야 한다. 순서가 요구되지 않는다면, block을 concurrent dispatch queue에 추가하거나 필요에 따라 몇 개의 다른 dispatch queue에 추가한다.

만약 작업을 operation 객체를 이용해서 구현했다면, 큐 선택은 객체를 구성하는 것보다 종종 덜 흥미롭다. operation 객체를 연속적으로 수행하게 하기 위해서는 관련된 객체들 사이의 종속성을 설정해야 한다. 종속성은 한 operation이 종속적인 다른 객체가 일을 끝내기 전까지 객체가 실행되는 것을 막는다.



#### 효율성을 높이기 위한 팁

코드를 더 작은 단위의 작업으로 간단히 분류해서 큐에 추가하는 방법 외에도 전반적인 코드의 효율성을 큐를 이용해 높이는 방법이 있다.

* **메모리 사용량이 중요한 경우 작업 안에서 직접 값을 계산하라**. 앱이 이미 메모리에 바인딩되어 있는 경우, 값을 직접 계산하는 것이 메인 메모리에서 캐시된 값을 불러 오는 것보다 빠를 수 있다. 값을 직접 계산하는 것은 주어진 프로세서 코어의 레지스터와 캐시를 직접 사용하는데, 이는 메인 메모리보다 훨씬 빠르다. 물론 성능 테스트를 해 봐야 한다.
* **연속적인 작업을 미리 식별하고 이를 동시에 수행할 수 있게 할 수 있는 것을 해라**. 만약 작업이 공유 자원에 의존해서 반드시 연속적으로 실행되어야 한다면 공유 자원을 없앨 수 있도록 구조를 변경하는 것을 고려해라. 각각의 클라이언트에게 자원을 복사하거나, 자원을 모두 지우는 것을 고려해 볼 수 있다.
* **lock의 사용을 피하라**. dispatch queue와 operatiion queue에서 제공되는 도움으로 lock을 만든느 것은 대부분의 상황에서 불필요해졌다. 공유 자원을 보호하기 위해서 lock을 사용하기 보다, serial queue를 이용해서 순서에 맞게 작업을 실행시켜라. (또는 operation 객체의 종속성을 이용하라.)

* **가능하다면 시스템 프레임워크에 의존하라**. 동시성을 얻는 최고의 방법은 시스템 프레임워크가 제공하는 빌트-인 동시성으로부터 이점을 취하는 것이다.  많은 프레임워크는 스레드와 다른 기술들을 내재적으로 동시성 행위를 실행하기 위해 사용하고 있다. 작업을 정의할 때, 수행하고자 하는 것이 이미 존재하는 프레임워크가 함수나 메서드를 정의하고 있고, 그것이 동시에 작동하는 지 살펴 봐라. 그 API를 사용하는 것은 들일 노력을 줄이고, 최대의 동시성을 제공할 것이다.



### 성능 영향

operation queuee, dispatch queue, dispatch source는 더 쉽게 코드들을 동시적으로 실행할 수 있게 해 준다. 그러나 이 기술들을 사용하는 것이 앱의 효율성 또는 응답성을 올려준다고 보장하지 않는다. 필요에 따라 효과적으로, 앱의 다른 리소스들에 부담을 주지 않는 방식으로 큐를 사용하는 것은 여전히 개발자의 책임이다. 예를 들어 10,000개의 operation 객체를 operation queue에 제출했을 때, 이렇게 함으로써 앱이 적은 양의 메모리를 할당 받을 수 있다. 이는 페이징과 성능 하락을 야기할 수 있다.

어떤 양의 동시성이든 도입하기 전에 (큐를 사용하던 스레드를 사용하던) 항상 현재 앱의 성능을 반영할 수 있는 기준 매트릭스를 수집해야 한다. 변화를 도입하고 난 이후에 추가적인 매트릭스를 모으고 이를 기준과 비교하여 앱의 전반적인 효율성이 향상되었는 지 확인한다. 만약 동시성의 도입이 앱을 비효율적이게 만들거나 응답성을 떨어뜨렸다면, 사용 가능한 성능 툴을 이용해서 가능한 원인들을 체크해봐야 한다.

성능과 사용 가능한 성능 툴에 대한 정보가 필요하다면 더 심화된 성능과 관련된 토픽인 [Performance Overview](https://developer.apple.com/library/archive/documentation/Performance/Conceptual/PerformanceOverview/Introduction/Introduction.html#//apple_ref/doc/uid/TP40001410) 를 확인하라.



### 동시성과 그 외 기술

코드를 모듈화된 작업으로 분리하는 것은 앱의 동시성을 향상시키는 가장 좋은 방법이다. 그러나 이러한 설계 관점은 언제나 모든 앱의 필요를 만족시키지는 못한다. 작업이 어떤 것이냐에 따라, 앱의 전반적인 동시성을 향상시킬 수 있는 추가적인 옵션이 있을 수 있다. 이 섹션에서는 설계의 일부로 사용하는 다른 기술들에 대해 간략하게 설명한다.



#### OpenCL과 동시성

OS X에서 OpenCL(Open Computing Language)은 컴퓨터의 그래픽 프로세서에서 범용 계산을 수행하기 위한 표준 기반 기술이다. OpenCL은 대규모 데이터 셋에 적용할 잘 정의된 계산 셋이 있는 경우 사용하기 좋은 기술이다. 예를 들어 OpenCL을 사용해서 이미지의 픽셀에 대한 필터 계산을 수행하거나 이를 사용해서 한 번에 여러 값에 대한 복잡한 수학 계산을 수행할 수 있다. 즉, OpenCL은 병렬로 작동 할 수 있는 문제 셋에 적합하다.

OpenCL이 대규모의 병렬 데이터 연산 수행에 좋지만, 범용 연산에는 부적합하다. GPU에 의해 작동될 수 있도록 데이터 및 필요한 작업 커널을 준비하고 그래픽 카드로 전송하는 데에는 많은 노력이 필요하다. 비슷하게 OpenCL에서 생성된 결과를 얻는 데는 많은 노력이 필요하다. 그 결과 시스템과 상호 작용하는 작업은 보통 OpenCL을 이용하도록 권장되지 않는다. 예를 들어 OpenCL을 사용해서 파일로부터의 데이터나 네트워크 스트림을 처리하지 않는다. 대신, OpenCL을 수행하는 일은 그래픽 프로세서로 전송되고 독립적으로 계산될 수 있도록 훨씬 더 독립적이어야 한다.

OpenCL에 대한 더 많은 정보와 어떻게 사용하는 지를 알고 싶다면, [OpenCL Programming Guide for Mac](https://developer.apple.com/library/archive/documentation/Performance/Conceptual/OpenCL_MacProgGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008312) 을 확인하라.



### 스레드를 사용해야 할 때

operation queue와 dispatch queue가 작업들을 동시적으로 수행하기에 더 선호되는 방법이지만 이것이 만병통치약은 아니다. 앱에 따라, 커스텀 스레드를 생성할 필요가 있다. 만약 커스텀 스레드를 생성한다면, 가능한 적은 양의 스레드를 생성하도록 노력해야 하고 생성한 스레드들을 특정 작업을 위해서만 사용해야 한다.

스레드는 여전히 반드시 실시간으로 실행되어야 하는 코드를 구현하는 데 좋은 방법이다. dispatch queue는 작업의 시도를 가능한 빠르게 실행하지만 실시간 제약 조건을 만족하지 못한다. 만약 백그라운드에서 실행되는 더 예측 가능한 행위가 필요하다면, 스레드는 여전히 좋은 대안이다.

스레드 프로그래밍에서, 스레드를 신중하고 정말로 필요할 때 써야 한다. 스레드 패키지에 대한 더 많은 정보와 어떻게 사용하는 지를 보고 싶다면 [Threading Programming Guide](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/Introduction/Introduction.html#//apple_ref/doc/uid/10000057i) 를 확인하라.
