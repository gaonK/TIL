# TDD by Example Part. 1

## Chapter 1
 * 우리가 알고 있는 작업해야 할 테스트 목록을 만들었다.
 * 오퍼레이션이 외부에서 어떻게 보이길 원하는지 말해주는 이야기를 코드로 표현했다.
 * JUnit에 대한 상세한 사항들은 잠시 무시하기로 했다.
 * 스텁 구현을 통해 테스트를 컴파일했다.
 * 끔찍한 죄악을 범하여 테스트를 통과시켰다.
 * 돌아가는 코드에서 상수를 변수로 변경하여 점진적으로 일반화했다.
 * 새로운 할일들을 한번에 처리하는 대신 할일 목록에 추가하고 넘어갔다.
 
 ## Chapter 2
 * 설계상의 결함(Dollar 부작용)을 그 결함으로 인해 실패하는 테스트로 변환했다.
 * 스텁 구현으로 빠르게 컴파일을 통과하도록 만들었다.
 * 올바르다고 생각하는 코드를 입력하여 테스트를 통과했다.
 
 ## Chapter 3
 * 우리는 디자인 패턴(값 객체)이 하나의 또 다른 오퍼레이션을 암시한다는 걸 알아챘다.
 * 해당 오퍼레이션을 테스트했다.
 * 해당 오퍼레이션을 간단히 구현했다.
 * 곧장 리팩토링하는 대신 테스트를 조금 더 했다.
 * 두 경우를 모두 수용할 수 있도록 리팩토링했다.
 
 ## Chapter 4
 * 오직 테스트를 향상시키기 위해서만 개발된 기능을 사용했다.
 * 두 테스트가 동시에 실패하면 망한다는 점을 인식했다.
 * 위험 요소가 있음에도 계속 진행했다.
 * 테스트와 코드 사이의 결합도를 낮추기 위해, 테스트하는 객체의 새 기능을 사용했다.
 
 ## Chapter 5
 * 큰 테스트를 공략할 수 없다. 그래서 진전을 나타낼 수 잇는 자그마한 테스트를 만들었다.
 * 뻔뻔스럽게도 중복을 만들고 조금 고쳐서 테스트를 작성했다.
 * 설상가상으로 모델 코드까지 도매급으로 복사하고 수정해서 테스트를 통과했다.
 * 중복이 사라지기 전에는 집에 가지 않겠다고 약속했다.
 
 ## Chapter 6
 * 공통된 코드를 첫 번재 클래스(Dollar)에서 상위 클래스(Money)로 단계적으로 옮겼다.
 * 두 번째 클래스(Franc)도 Money의 하위 클래스로 만들었다.
 * 불필요한 구현을 제거하기 전에 두 equals() 구현을 일치시켰다.
 
 ## Chapter 7
 * 우릴 괴롭히던 결함을 끄집어내서 테스트에 담아냈다.
 * 완벽하진 않지만 그럭저럭 봐줄 만한 방법 (getClass())으로 테스트를 통과하게 만들었다.
 * 더 많은 동기가 있기 전에는 더 많은 설계를 도입하지 않기로 했다.
 
 ## Chapter 8
 * 동일한 메서드(times)의 두 변이형 메서드 서명부를 통일시킴으로써 중복 제거를 향해 한 단계 더 전진했다.
 * 최소한 메서드 선언부만이라도 공통 상위 클래스(superclass)로 옮겼다.
 * 팩토리 메서드를 도입하여 테스트 코드에서 콘크리트 하위 클래스의 존재 사실을 분리해냈다.
 * 하위 클래스가 사라지면 몇몇 테스트는 불필요한 여분의 것이 된다는 것을 인식했다. 하지만 일단 그냥 뒀다.
 
 ## Chapter 9
 * 큰 설계 아이디어를 다루다가 조금 곤경에 빠졌다. 그래서 좀 전에 주목했던 더 작은 작업을 수행했다.
 * 다른 부분들을 호출자(팩토리 메서드)로 옮김으로써 두 생성자를 일치시켰다.
 * times()가 팩토리 메서드를 사용하도록 만들기 위해서 리팩토링을 잠시 중단했다.
 * 비슷한 리팩토링(Franc에 했던 일을 Dollar에도 적용)을 한번의 큰 단계로 처리했다.
 * 동일한 생성자들을 상위 클래스로 옮겼다.
 
 ## Chapter 10
 * 두 times()를 일치시키기 위해 그 메서드들이 호출하는 다른 메서드들을 인라인시킨 후 상수를 변수로 바꿔주었다.
 * 단지 디버깅을 위해 테스트 없이 toString()을 작성했다.
 * Franc 대신 Money를 반환하는 변경을 시도한 뒤 그것이 잘 작동할지를 테스트가 말하도록 했다.
 * 실험해본 걸 뒤로 물리고 또 다른 테스트를 작성했다. 테스트를 작동했더니 실험도 제대로 작동했다.
 
 ## Chapter 11
 * 하위 클래스의 속을 들어내는 걸 완료하고, 하위 클래스를 삭제했다.
 * 기존의 소스 구조에서는 필요했지만 새로운 구조에서는 필요 없게 된 테스트를 제거했다.

## Chapter 12
* 큰 테스트를 작은 테스트($5 + 10CHF에서 $5 + $5)로 줄여서 발전을 나타낼 수 있도록 했다.
* 우리에게 필요한 계산(computatioin)에 대한 가능한 메타포들을 신중히 생각해봤다.
* 새 메타포에 기반하여 기존의 테스트를 재작성했다.
* 테스트를 빠르게 컴파일했다.
* 그리고 테스트를 실행했다.
* 진짜 구현을 만들기 위해 필요한 리팩토링을 약간의 전율과 함께 기대했다.

## Chapter 13
* 모든 중복이 제거되기 전까지는 테스트를 통과한 것으로 치지 않았다.
* 구현하기 위해 역방향이 아닌 순방향으로 작업했다.
* 앞으로 필요할 것으로 예상되는 객체(Sum)의 생성을 강요하기 위한 테스트를 작성했다.
* 빠른 속도로 구현하기 시작했다(Sum의 생성자).
* 일단 한 곳에 캐스팅을 이용해서 코드를 구현했다가, 테스트가 돌아가자 그 코드를 적당한 자리로 옮겼다.
* 명시적인 클래스 검사를 제거하기 위해 다형성을 사용했다.

## Chapter 14
* 필요할 거라고 생각한 인자를 빠르게 추가했다.
* 코드와 테스트 사이에 있는 데이터 중복을 끄집어냈다.
* 자바의 오퍼레이션에 대한 가정을 검사해보기 위한 테스트(testArray-Equals)를 작성했다.
* 별도의 테스트 없이 전용(private) 도우미(helper) 클래스를 만들었다.
* 리팩토링하다가 실수를 했고, 그 문제를 분리하기 위해 또  하나의 테스트를 작성하면서 계속 전진해 가기로 선택했다.

## Chapter 15
* 원하는 테스트를 작성하고, 한 단계에 달성할 수 있도록 뒤로 물렀다.
* 좀더 추상적인 선언을 통해 가지에서 뿌리(애초의 테스트 케이스)로 일반화했다.
* 변경 후(Expresion fiveBucks), 그 영향을 받은 다른 부분들을 변경하기 위해 컴파일러의 지시를 따랐다(Expression에 plus()를 추가하기 등등).

## Chapter 16
* 미래에 코드를 읽을 다른 사람들을 염두에 둔 테스트를 작성했다.
* TDD와 여러분의 현재 개발 스타일을 비교해 볼 수 있는 실험 방법을 제시했다.
* 또 한 번 선언부에 대한 수정이 시스템 나머지 부분으로 번져갔고, 문제를 고치기 위해 여러 컴파일러의 조언을 따랐다.
* 잠시 실험을 시도했는데, 제대로 되지 않아서 버렸다.

## Chapter 17
* 다음에 할 일
    * Sum.plus(), Money.plus() 사이의 중복 제거
    * 어떤 테스트들이 추가로 더 필요할 지 생각하기
    * 말과 개념이 잘 통하는지, 현재의 설계로 제거하기 힘든 중복이 있는지 확인  
* 프로세스
    * TDD의 주기
        * 작은 테스트를 추가한다.
        * 모든 테스트를 실행하고, 실패하는 것을 확인한다.
        * 코드에 변화를 준다.
        * 모든 테스트를 실행하고, 성공하는 것을 확인한다.
        * 중복을 제거하기 위해 리팩토링한다.
* 테스트의 질
    * TDD의 부산물인 테스트는 시스템의 수명이 다할 때까지 함께 유지돼야 할 만큼 유용하다.
    * 하지만 이런 테스트들을 대체할 수는 없음.
        * 성능 테스트
        * 스트레스 테스트
        * 사용성 테스트
    * 테스트에 사용되는 지표
        * 명령문 커버리지(statement coverage)
        * 결합 삽입(defect insertion)
* TDD를 가르칠 때 사람들이 자주 놀라는 세 가지
    * 테스트를 확실하게 돌아가게 만드는 세 가지 접근법: 가짜로 구현하기, 삼각측량법, 명백하게 구현하기
    * 설계를 주도하기 위한 방법으로 테스트 코드와 실제 코드 사이의 중복 제거하기
    * 길이 미끄러우면 속도를 줄이고 상황이 좋으면 속도를 높이는 식으로 테스트 사이의 간격을 조절할 수 있는 능력