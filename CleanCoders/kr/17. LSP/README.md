# 17. LSP

> Liskov Substitution Principle
>
> 리스코프 치환 원칙

리스코프 치환 원칙은 왜! 왜 중요한지 알아보자. 애석하게도 강의는 6분 밖에 되지 않았다. 이건 정말 말도 안 되는 일. ㅠ

리스코프 치환 원칙이 뭔데요! 😂

```
자료형 S가 자료형 T의 하위형이라면 필요한 프로그램의 속성(정확성, 수행하는 업무 등)의 변경 없이 자료형 T의 객체를 자료형 S의 객체로 교체(치환)할 수 있어야 한다는 원칙이다.
```

이는 **상위 타입의 객체를 하위 타입의 객체로 치환해도 상위 타입을 사용하는 프로그램은 정상적으로 동작해야 함**을 의미한다. 상위 클래스는 파생된 하위 클래스 객체의 상세를 알지 못하고도 사용될 수 있어야 한다. 그러기 위해선 하위 타입의 객체는 최소한 상위 타입의 객체가 할 수 있는 일은 할 수 있어야 함을 의미한다. 상위 타입과 하위 타입의 관계는 IS-A여야 한다는 것이다. 

LSP의 위반 예시로 흔한 것은 Rectangle과 Square 예시이다. Square IS-A Rectangle 임은 기하학에선 너무나 당연한 사실이다. 하지만 이 예시는 LSP를 위반한다. 상위 타입인 Rectangle이 넓이를 계산하는 getArea 메소드가 있다고 하자. Square의 getArea 메소드는 상위 타입인 Rectangle의 getArea와 동일하게 동작하지 않는다. 즉, Rectangle은 Square로 치환될 수 없고 이는 LSP 위반이라 할 수 있다. 이처럼 현실에서의 관계가 이를 표현 또는 대리하는 소프트웨어에 적용되지 않는 것을 The Representative Rule이라고 한다. 

LSP는 상속에 대한 룰이다. LSP를 통해 상속을 이용한 코드 재사용과 polymorphism이 구현 된다. 사용자 관점에서 기반 타입의 객체만 알고, 하위 객체의 구현을 모르는 상태로 사용할 수 있게 해 준다. 만약 LSP가 깨진다면 하위 타입이 추가될 때마다 사용자의 코드가 변경되어야 한다. 이처럼 LSP의 위반은 OCP의 위반으로 이어진다.  `instanceof`나, `downcast`의 사용은 LSP 위반의 징조라고 할 수 있으니 주의하자.



#### 참고자료

http://wiki.c2.com/?LiskovSubstitutionPrinciple