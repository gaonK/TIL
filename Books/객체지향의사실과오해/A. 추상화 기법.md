# 추상화 기법

* 분류와 인스턴스화: **분류**는 객체의 구체적인 세부 사항을 숨기고 인스턴스 간에 공유하는 공통적인 특성을 기반으로 범주를 형성하는 과정.
분류의 역은 범주로부터 객체를 생성하는 **인스턴스화** 과정.

* 일반화와 특수화: **일반화**는 범주 사이의 차이를 숨기고 범주 간에 공유하는 공통적인 특성을 강조. 일반화의 역이 **특수화**.

* 집합과 분해: **집합**은 부분과 관련된 세부 사항을 숨기고 부분을 사용해서 전체를 형성하는 과정. 집합의 반대 과정은 전체를 부분으로 분해하는 **분해** 과정.


객체지향의 가장 큰 장점은 동일한 추상화 기법을 프로그램의 분석, 설계, 구현 단계에 걸쳐 일관성 있게 적용할 수 있다는 것이다.


## 분류와 인스턴스화

객체를 분류하고 **범주**로 묶는 것은 객체들의 특정 집합에 공통의 **개념**을 적용하는 것. 세상에 존재하는 객체에 개념을 적용하는 과정을 **분류**라고 한다. 
객체지향에서 개념을 가리키는 표준 용어는 **타입**이다. 
분류란 객체들을 동일한 타입 또는 범주로 묶는 과정을 의미하고 객체를 타입의 인스턴스라고 한다.


### 타입

* 심볼: 타입을 가리키는 간략한 이름이나 명칭.
* 내연: 타입의 완전한 정의. 내연의 의미를 이용해 객체가 타입에 속하는지 여부를 확인할 수 있다.
* 외연: 타입에 속하는 모든 객체들의 집합.


### 외연과 집합

타입의 외연은 타입에 속하는 객체들의 집합으로 표현한다. 집합은 외연을 가리키는 다른 명칭이다.

* 단일 분류(single classification): 한 객체가 한 시점에 하나의 타입에만 속하는 것.
* 다중 분류(multiple classification): 한 객체가 한 시점에 여러 타입에 속하는 것.

다중 분류와 다중 상속은 다르다. 다중 상속은 하나의 타입이 다수의 슈퍼타입을 가질 수 있도록 허용하지만 타입 정의를 생략할 수는 없다.
다중 분류는 특정한 타입을 정의하지 않고도 하나의 객체가 서로 다른 타입의 인스턴스가 되도록 허용한다.
대부분의 객체지향 언어는 다중 분류를 지원하지 않는다. 


### 클래스

클래스는 타입을 구현하는 가장 보편적인 방법이다. 클래스와 타입은 동일한 개념이 아니다. 
클래스는 타입을 구현하는 용도 외에도 코드를 재사용하는 용도로 사용되기도 한다.
클래스 외에도 인스턴스를 생성할 수 없는 추상 클래스나 인터페이스를 이용해 타입을 구현할 수 있다.

자바스크립트처럼 클래스가 존재하지 않는 프로토타입 기반의 언어에서 분류와 인스턴스화는 프로토타입이라는 객체의 복사를 통해 이루어진다.


## 일반화와 특수화

### 범주의 계층

계층의 상위에 위치한 범주를 계층의 하위에 위치한 범주의 일반화라고 하고, 계층의 하위에 위치한 범주는 계층의 상위에 위치한 범주의 특수화라고 한다. 


### 서브타입

객체지향의 세계에서 범주는 개념을 의미하고, 개념은 타입을 의미한다. 따라서 일반화와 특수화는 계층 구조 안에 존재하는 타입 간의 관계를 의미한다. 
슈퍼타입(supertype), 서브타입(subtype)은 일반화 특수화 관계로 표현할 수 있다. 
서브타입은 슈퍼타입이 가진 본질적인 속성과 함께 자신만의 추가적인 속성을 가진다. 
서브타입은 슈퍼타입의 본질적인 속성을 모두 포함하기 때문에 계층에 속하는 모든 서브타입들이 슈퍼타입의 속성을 공유한다는 것을 쉽게 예상할 수 있다.

크레이그 라만은 어떤 타입이 다른 타입의 서브타입이 되기 위해서는 '100% 규칙'과 'is-a 규칙'을 준수해야 한다고 말한다. 

* 100% 규칙: 슈퍼타입의 정의가 100% 서브타입에 적용돼야만 한다. 서브타입은 속성과 연관관계 면에서 슈퍼타입과 100% 일치해야 한다.
* Is-a 규칙: 서브타입의 모든 인스턴스는 슈퍼타입 집합에 포함돼야 한다. 이는 대개 영어로 서브타입은 슈퍼타입이다라는 구문을 만듦으로써 테스트할 수 있다. 


### 상속

프로그래밍 언어를 이용해 일반화와 특수화 관계를 구현하는 가장 일반적인 방법은 클래스 간의 상속을 사용하는 것이다. 

일반화의 원칙은 한 타입이 다른 타입의 서브타입이 되기 위해서 슈퍼타입에 순응(comformance)해야 한다는 것이다.

* 구조적인 순응: 기대 집합은 속성과 연관관계에 관한 것. (타입의 내연과 관련된 100% 규칙)
* 행위적인 순응: 기대 집합은 행위가 동일한 계약을 기반으로 하느냐. (리스코프 치환 원칙, LSP) 서브타입은 슈퍼타입을 행위적으로 대체 가능해야 한다. 

상속은 코드 중복을 방지하고 공통 코드를 재사용하기 위한 언어적 메커니즘을 제공하는 것.

* 서브타이핑(subtyping): 서브클래스가 슈퍼클래스를 대체할 수 있는 경우 -> 설계의 유연성이 목표, 인터페이스 상속
* 서브클래싱(subclassing): 서브클래스가 슈퍼클래스를 대체할 수 없는 경우 -> 코드의 중복 제거와 재사용이 목적, 구현 상속

모든 상속이 서브타이핑인 것은 아니다. 서브클래스가 슈퍼클래스를 대체할 수 없고 단지 코드만 공유한다면 서브클래싱이라고 한다. 

여러 클래스로 구성된 상속 계층에서 수신된 메시지를 이해하는 기본적인 방법은 클래스 간의 위임(delegation)을 사용하는 것이다.
코드를 이해할 수 없는 경우 부모 클래스로 메시지를 위임한다. 
이러한 위임 사슬은 어떤 클래스가 메시지를 처리하거나 최상위 부모 클래스에게 위임될 때까지 계속된다. 

프로토타입 기반 언어에서도 메시지는 클래스 기반의 객체지향 언어와 동일하게 위임 메커니즘에 의해 처리된다. 
대신 자식 클래스, 부모 클래스 사이가 아니라 자식 객체, 부모 객체 사이에서 위임이 이뤄진다. 


## 집합과 분해

### 계층적인 복합성

* 복잡성은 '계층'의 형태를 띤다.
* 단순한 형태로부터 복잡한 형태로 진화하는 데 걸리는 시간은 그 사이에 존재하는 '안정적인 형태'의 수와 분포에 의존한다.

집합의 가치는 많은 수의 사물들의 형상을 하나의 단위로 다룸으로써 복잡성을 줄일 수 있다는 데 있다. 즉, 불필요한 세부사항을 추상화한다. 집합은 추상화 메커니즘이면서 캡슐화 메커니즘이다. 

그러나 필요한 시점에는 전체를 분해함으로써 그 안에 포함된 부분들을 새로운 전체로 다룰 수 있다. 


### 합성 관계

객체와 객체 사이의 전체-부분 관계를 구현하기 위해서 합성 관계를 사용한다. 합성 관계는 부분을 전체 안에 캡슐화함으로써 인지 과부하를 방지한다.

합성 관계와 연관 관계 사이의 차이가 항상 명확하진 않지만 일반적으로 합성 관계로 연결된 객체는 포함하는 객체가 제거될 때 내부에 포함된 객체도 함께 제거된다.
연관 관계로 연결된 두 객체는 생명주기에 어떤 제약도 부과되지 않는다. 


### 패키지
소프트웨어의 전체적인 구조를 파악하기 위해 관련된 클래스 집합을 하나의 논리적 단위로 묶는 구성 요소를 패키지 또는 모듈이라 한다. 
클래스의 집합을 캡슐화함으로써 전체적인 복잡도를 낮출 수 있고, 응집도 높은 클래스 집합을 패키지로 모으면 패키지 경계를 넘나들 필요가 적어진다. 
패키지와 모듈은 시스템의 구조를 추상화한다. 



