# 8장: 통합점: 게이트웨이, 터널, 릴레이

### 8.1 게이트웨이

웹에 더 복잡한 리소스를 올려야 할 필요가 생기면서 모든 리소스를 한 개의 애플리케이션으로만 처리할 수 없게 되었다. 이에 인터프리터 같이 리소스를 받기 위한 경로를 안내하는 역할을 하는 게이트웨이가 고안되었다. 게이트웨이는 서로 다른 프로토콜과 애플리케이션 간의 HTTP 인터페이스다. 게이트웨이는 요청을 받고 응답을 보내는 포털 같이 동작하는데, 동적인 콘텐츠를 생성하거나 데이터베이스에 질의를 보낼 수 잇다. 게이트웨이는 HTTP 트래픽을 다른 프로토콜로 자동으로 변환하여, HTTP 클라이언트가 다른 프로토콜을 알 필요 없이 서버에 접속할 수 있게 해 주기도 한다.

#### 8.1.1 클라이언트 측 게이트웨이와 서버 측 게이트웨이

```
<클라이언트 프로토콜>/<서버 프로토콜>
```

게이트웨이가 HTTP 클라이언트와 NNTP 뉴스 서버 사이에 있으면 HTTP/NNTP 게이트웨이가 된다.

* 서버 측 게이트웨이는 클라이언트와 HTTP로 통신하고, 서버와는 외래 프로토콜로 통신한다.
* 클라이언트 측 게이트웨이는 클라이언트와 외래 프로토콜로 통신하고, 서버와는 HTTP로 통신한다.



### 8.2 프로토콜 게이트웨이

#### 8.2.1 HTTP/*: 서버 측 웹 게이트웨이

서버 측 웹 게이트웨이는 클라이언트로부터 HTTP 요청이 원 서버 영역으로 들어오는 시점에 클라이언트 측의 HTTP 요청을 외래 프로토콜로 전환한다.

#### 8.2.2 HTTP/HTTPS: 서버 측 보안 게이트웨이

암호화하여 개인 정보 보호와 보안을 제공하는 데 게이트웨이를 사용할 수 있다. 클라이언트는 일반 HTTP를 사용하여 웹을 탐색할 수 있지만, 게이트웨이는 자동으로 사용자의 모든 세션을 암호화할 것이다.

#### 8.2.3 HTTPS/HTTP: 클라이언트 측 보안 가속 게이트웨이

웹 서버의 앞단에 위치해서 보이지 않는 인터셉트 게이트웨이나 리버스 프락시 역할을 한다. HTTPS 트래픽을 받아서 복호화하고 웹 서버로 보낼 일반 HTTP 요청을 만든다. 이런 게이트웨이는 원 서버보다 효율적으로 보안 트래픽을 복호화하는 암호화 하드웨어를 내장해서 원 서버 부하를 줄이기도 한다. 이 경우 게이트웨이와 원 서버 간에 있는 네트워크가 안전한지 확실하게 확인해야 한다.



### 8.3 리소스 게이트웨이

게이트웨이의 가장 일반적인 형태인 애플리케이션 서버는 목적지 서버와 게이트웨이를 한 개의 서버로 결합한다. 애플리케이션 서버는 HTTP를 통해서 클라이언트와 통신하고 서버 측에 있는 애플리케이션 프로그램에 연결하는 서버 측 게이트웨이다. 애플리케이션은 게이트웨이의 애플리케이션 프로그래밍 인터페이스(Application Programming Interface)를 통해서 요청을 서버에서 동작하고 있는 애플리케이션에 전달한다.

게이트웨이를 통해야 받을 수 있는 리소스 요청이 들어오면, 서버는 헬퍼 애플리케이션을 생성해서 요청을 처리한다. 

#### 8.3.1 공용 게이트웨이 인터페이스

공용 게이트웨이 인터페이스(CGI)는 최초의 서버 확장이자 지금까지도 가장 널리 쓰이는 서버 확장이다. CGI 애플리케이션이 서버와 분리되면서 수많은 언어로 구현할 수 있게 되었다. CGI는 단순하므로 거의 모든 HTTP 서버가 지원한다.

CGI는 거의 모든 리소스 형식과 서버의 접점에 있으면서 필요에 따라 어떤 변형이든 처리해내는 단순한 기능을 제공한다. 인터페이스는 문제가 많은 확장으로부터 서버를 보호한다는 점에서 훌륭하다고 할 수 있지만 이런 분리 때문에 성능 관련한 비용이 발생한다. 이런 성능 저하 문제를 해결하기 위해 Fast CGI가 개발되었다.

#### 8.3.2 서버 확장 API



### 8.4 애플리케이션 인터페이스와 웹 서비스



### 8.5 터널

웹 터널은 HTTP 프로토콜을 지원하지 않는 애플리케이션에 HTTP 애플리케이션을 사용해 접근하는 방법을 제공한다. 

#### 8.5.1 CONNECT로 HTTP 터널 커넥션 맺기

웹 터널은 HTTP의 CONNECT 메서드를 사용해서 커넥션을 맺는다. CONNECT 메서드는 터널 게이트웨이가 임의의 목적 서버와 포트에 TCP 커넥션을 맺고 클라이언트와 서버 간에 오는 데이터를 무조건 전달하기를 요청한다. 

##### CONNECT 요청

```
CONNECT home.netscape.com:443 HTTP/1.0
User-agent: Mozilla/4.0
```

##### CONNECT 응답

```
HTTP/1.0 200 Connection Established
Proxy-agent: Netscape-Proxy/1.1
```

일반적인 HTTP 응답과는 달리 Content-Type 헤더를 포함할 필요가 없다.

#### 8.5.2 데이터 터널링, 시간, 커넥션 관리

터널을 통해 전달되는 데이터는 게이트웨이에서 볼 수 없어서 게이트웨이는 패킷의 순서나 흐름에 대한 어떤 가정도 할 수 없다. 터널이 일단 연결되면, 데이터는 언제 어디로든 흘러가버릴 수 있다.

클라이언트는 성능을 높이기 위해 CONNECT 요청을 보낸 다음, 응답을 받기 전에 터널 데이터를 전송할 수 있다. 게이트웨이는 네트워크 I/O 요청이 헤더 데이터만을 반환해줄 거라고 가정할 수 없어서 게이트웨이는 커넥션이 맺어지는 대로 헤더를 포함해서 읽어들인 모든 데이터를 서벙에 전송해야 한다. 요청 후에 터널을 통해 데이터를 전송한 클라이언트는 인증요구(authentication challenge)나 200 외의 응답이 왔을 때 요청 데이터를 다시 보낼 준비가 되어 있어야 한다.

#### 8.5.3 SSL 터널링

웹 터널은 원래 방화벽을 통해서 암호화된 SSL 트래픽을 전달하려고 개발되었다. 하지만 SSL과 같이 암호화된 프로토콜은 정보가 암호화되어 있기 대문에 낡은 방식의 프락시에서 처리되지 않는다. 

터널은 HTTP가 아닌 트래픽이 포트를 제한하는 방화벽을 통과할 수 있게 해준다. 

#### 8.5.4 SSL 터널링 vs HTTP/HTTPS 게이트웨이

HTTP/HTTPS 게이트웨이 단점

* 클라이언트-게이트웨이 사이에는 보안이 적용되지 않은 일반 HTTP 커넥션이 맺어져 있다.
* 프락시가 인증을 담당하고 있기 때문에, 클라이언트는 원격 서버에 SSL 클라이언트 인증을 할 수 없다.
* 게이트웨이는 SSL을 완벽히 지원해야 한다. 

이때 SSL 터널링을 사용하면 프락시에 SSL을 구현할 필요가 없다. 

#### 8.5.5 터널 인증

프락시 인증 기능은 클라이언트가 터널을 사용할 수 있는 권한을 검사하는 용도로 터널에서 사용 가능하다.

#### 8.5.6 터널 보안에 대한 고려사항들

보통의 터널 게이트웨이는 통신하고 잇는 프로토콜이 터널을 올바른 용도로 사용하고 있는지 검증할 방법이 없다. 터널의 오용을 최소화하기 위해 게이트웨이는 HTTPS 전용 포트인 443과 같이 잘 알려진 특정 포트만을 터널링할 수 있게 허용해야 한다.



### 8.6 릴레이

HTTP 릴레이는 HTTP 명세를 완전히 준수하지는 않는 간단한 HTTP 프락시다. 릴레이는 커넥션을 맺기 위한 HTTP 통신을 한 다음, 바이트를 맹목적으로 전달한다. HTTP는 복잡하기 때문에 이렇게 간단한 프락시를 구현하는 방식이 유용할 때가 있다. 단순 필터링이나 진단 혹은 콘텐츠 변환을 하는데 사용되기도 한다. 하지만 이는 잠재적으로 심각한 상호 운용 문제를 가지고 있기 때문에 주의해서 배포해야 한다.