# 13장: 다이제스트 인증

기본 인증은 편리하고 유연하지만 안전하지 않다. 메시지를 위조하지 못하게 보호하려는 어떠한 시도도 하지 않는다. 
다이제스트 인증은 기본 인증과 호환되는 더 안전한 대체제로서 개발되었다.
다이제스트 인증은 널리 쓰이지는 않지만 보안 트랜잭션을 구현하고자 하는 사람들에게 이 개념은 유용하다. 

## 13.1 다이제스트 인증의 개선점

* 비밀번호를 절대로 네트워크를 통해 평문으로 전송하지 않는다.
* 인증 체결을 가로채서 재현하려는 악의적인 사람들을 차단한다.
* 구현하기에 따라서, 메시지 내용 위조를 막는 것도 가능하다.
* 그 외 몇몇 잘 알려진 형태의 공격을 막는다.

다이제스트 인증은 안전한 HTTP 트랜잭션을 위한 많은 요구사항을 만족하지 못한다.
기본 인증을 대체하기 위해 설계된 다이제스트 인증은 기본 인증보다는 훨씬 강력하다.


### 13.1.1 비밀번호를 안전하게 지키기 위해 요약 사용하기

* 클라이언트가 보호된 문서를 요구한다.
* 서버는 클라이언트가 비밀번호를 알고 있음을 스스로 증명하여 신원을 인증하기 전까지 문서를 제공하는 것을 거부한다.
* 서버는 클라이언트에게 사용자 이름과 요약된 형태의 비밀번호를 요구한다.
* 클라이언트는 비밀번호의 요약을 전달하여 자신이 비밀번호를 알고 있음을 증명한다.
* 서버는 클라이언트가 제공한 요약과 서버가 내부적으로 계산한 요약을 비교한다. (일치하면 클라이언트가 비밀번호를 알고 있는 것이다.)


### 13.1.2 단방 요약

요약은 '정보 본문의 압축'이다. 요약은 단방향 함수로 동작하고, 일반적으로 입력 가능한 무한 가지의 모든 입력값들을 유한한 범위의 압축으로 변환한다.
인기 있는 요약 함수 중 하나인 `MD5`는 임의의 바이트 배열을 원래 길이와 상관 없이 128 비트 요약으로 변환한다.

요약 함수는 보통 암호 체크섬(cryptographic checksums)으로 불리며, 단방향 해시 함수이거나 지문 함수(fingerprint function)이다.


### 13.1.3 재전송 방지를 위한 난스(nonce) 사용

단방향 요약은 비밀번호를 그대로 전송해야 할 필요를 없게 하고, 대신 비밀번호에 대한 요약을 보낸다.
쉽게 요약을 해독할 수 없음을 보장받기만 하면 된다.

요약은 비밀번호 자체와 다름 없기 때문에 재전송 공격을 막기 위해 서버는 클라이언트에게 난스라고 불리는 특별한, 자주 바뀌는 증표를 건네준다.
저장된 비밀번호 값은 특정 난스 값에 대해서만 유효하고, 비밀번호 없이 공격자가 올바른 요약을 계산하는 것은 가능하지 않다.

다이제스트 인증은 난스를 사용할 것은 요구하는데, 난스를 쓰지 않는 다이제스트 인증은 기본 인증만큼 허약하기 때문이다.
난스는 WWW-Authenticate 인증 요구에 담겨서 서버에서 클라이언트로 넘겨진다.


### 13.1.4 다이제스트 인증 핸드셰이크

HTTP 다이제스트 인증 프로토콜은 기본 인증에서 사용하는 것과 비슷한 헤더를 사용하는, 강화된 버전의 인증이다.

* 서버는 난스 값을 계산한다.
* 서버는 난스를 WWW-Authentcate 인증 요구 메시지에 담아, 서버가 지원하는 알고리즘 목록과 함께 클라이언트에 전송한다.
* 클라이언트는 알고리즘을 선택하고 비밀번호와 그 외 데이터에 대한 요약을 계산한다.
* 클라이언트는 Authorizaton 메시지에 요약을 담아 서버에게 돌려준다.
* 서버는 요약, 선택한 알고리즘, 그 외 보조 데이터들을 받고, 클라이언트가 했던 그대로 요약을 계산한다. 자신이 계산한 요약과 전송된 요약이 서로 같은지 확인한다.


## 13.2 요약 계산

다이제스트 인증의 핵심은 공개된 정보, 비밀 정보, 시한부 난스 값을 조합한 단방향 용ㄱ이다.

### 13.2.1 요약 알고리즘 입력 데이터

* 단방향 해시 함수 H(d)와 요약 함수 KD(s,d). 여기서 s는 비밀(secret)을, d는 데이터(data)를 의미한다.
* 비밀번호 등 보안 정보를 담고 있는 데이터 덩어리. A1
* 요청 메시지의 비밀이 아닌 속성을 담고 있는 데이터 덩어리. A2


### 13.2.2 H(d)와 KD(s,d) 알고리즘

다이제스트 인증은 여러 요약 알고리즘을 선택할 수 있도록 지원한다. 
알고리즘이 정해지지 않았다면 MD5가 기본값이다.


### 13.2.3 보안 관련 데이터(A1)

A1은 사용자 이름, 비밀번호, 보호 영역, 난스와 같은 비밀 보호 정보로 이루어져 있다.

A1을 계산할 수 있는 두 가지 방법

* MD5
* MD5-sess


### 13.2.4 메시지 관련 데이터(A2)

A2는 URL, 요청 메서드, 메시지 엔터티 본문과 같은 메시지 자체의 정보를 나타낸다.

A2의 사용법

* HTTP 요청 메서드와 URL만 포함하는 것.
* 메시지 무결성 검사를 제공하기 위해 메시지 엔터티 본문을 추가


### 13.2.5 요약 알고리즘 전반

H, KD, A1, A2로 요약을 계산하는 방법

* qop 옵션이 빠졌을 때, 비밀 정보와 난스가 붙은 메시지 데이터의 해시를 이용해 요약을 계산한다.
* qop가 'auth'이거나 'auth-int'일 때, 난스 횟수 집계 및 대칭 인증의 지원을 한다.


### 13.2.6 다이제스트 인증 세션

WWW-Authenticate 인증 요구에 대한 클라이언트 응답은, 인증 세션을 시작하게 한다.
인증 세션은 클라이언트가 보호 공간의 다른 서버로부터 다른 WWW-Authenticate 인증 요구를 받을 때까지 지속된다.
난스가 만료되면, 서버는 포함된 난스 값이 낡은 것일 수 있음을 감수하고 오래된 Authorization 헤더 정보를 받아들이는 것을 택할 수 있다.
아니면 새로운 난스 값과 함께 401 응답을 반환할 수도 있다.


### 13.2.7 사전(preemptive) 인가

일반적인 인증에서 각 요청은 트랜잭션이 완료되기 전에 요청/인증요구 사이클을 필요로 한다.
만약 클라이언트가 다음 난스가 무엇이 될지 미리 알고 있다면 서버가 물어보기 전 올바른 Authorization 헤더를 생성할 수 있고, 이 요청/인증요구 사이클은 생략할 수 있다.

사전 인가는 기본 인증에서는 사소하고 흔한 것이다.
다이제스트 인증에서의 사전 인가는 약간 복잡하다. 난스 기술이 재전송 공격을 저지하기 위한 것이기 때문이다.

클라이언트가 새 WWW-Authenticate 인증요구를 기다리지 않고 올바른 난스를 취득할 수 있는 방법

* 서버가 다음 난스를 Authentication-Info 성공 헤더에 담아서 미리 보낸다.
* 서버가 짧은 시간 동안 같은 난스를 재사용하는 것을 허용한다.
* 클라이언트와 서버가 동기화되어 있고 예측 가능한 난스 생성 알고리즘을 사용한다.


### 13.2.8 난스 선택

난스의 내용은 불투명하고 구현 의존적이지만 성능 수준, 보안, 편의성은 난스 선택에 달려 있다.

```
BASE64(타임스탬프 H(타임스탬프 ":" ETag ":"개인 키))
```

서버는 클라이언트 인증 헤더를 받은 뒤, 해시 부분을 재계산 해보고 클라이언트 인증 헤더의 난스와 일치하지 않거나 타임스탬프가 오래되었다면 요청을 거절한다.


### 13.2.9 상호 인증

RFC 2617은 클라이언트가 서버를 인증할 수 있도록 다이제스트 인증을 확장했다.
서버가 공유된 비밀 정보에 근거한 올바른 응답 요약을 생성할 수 있도록, 클라이언트 난스 값을 제공함으로써 가능해진다.
이후 서버는 이 요약을 Authentication-Info 헤더를 통해 클라이언트에 전달한다.


## 13.3 보호 수준(Quality of Protection) 향상

qop 필드는 요약 헤더의 세 가지 헤더 `WWW-Authenticate`, `Authorization`, `Authentication-Info`에 모두 존재할 수 있다.
qop 필드를 통해 클라이언트와 서버는 어떤 보호 기법을 어느 정도 수준으로 사용할 것인지 협상할 수 있다.


### 13.3.1 메시지 무결성 보호

### 13.3.2 다이제스트 인증 헤더


## 13.4 실제 상황에 대한 고려

### 13.4.1 다중 인증요구

서버는 한 리소스에 대해 여러 인증을 요구할 수 있다.
다중 인증요구에 직면했을 때, 클라이언트는 반드시 자신이 지원할 수 있는 가장 강력한 인증 메커니즘을 선택해야 한다.

다양한 인증 옵션을 제공하는 경우, '가장 허약한 연결부분'에 대한 보안 우려가 있다.
서버는 기본 인증을 제한적으로만 사용해야 하고 관리자는 사용자에게 보안 수준이 다른 여러 시스템에서 같은 비밀번호를 사용하는 것의 위험성에 대해 경고해야 한다.


### 13.4.2 오류 처리

다이제스트 인증에서 지시자나 그 값이 적절하지 않거나 요구된 지시자가 빠져 있는 경우 알맞은 응답은 400 Bad Request이다.
요청의 요약이 맞지 않으면 로그인이 실패했음을 기록해 두는 것이 좋다. 반복된 실패는 공격자가 비밀번호 추측을 시도하고 있음을 의미한다.
인증 서버는 반드시 'uri' 지시자가 가리키는 리소스가 요청줄에 명시된 리소스와 같음을 확인해야 한다.


### 13.4.3 보호 공간(Protection Space)

### 13.4.4 URI 다시 쓰기

### 13.4.5 캐시



## 13.5 보안에 대한 고려사항

### 13.5.1 헤더 부당 변경

### 13.5.2 재전송 공격

### 13.5.3 다중 인증 메커니즘

### 13.5.4 사전(dictionary) 공격

### 13.5.5 악의적인 프락시와 중간자 공격(Man-in-the-Middle Attack)

### 13.5.6 선택 평문 공격

### 13.5.7 비밀번호 저장










