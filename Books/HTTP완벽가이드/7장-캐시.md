# 7장: 캐시

### 7.1 불필요한 데이터 전송

불필요한 데이터 전송은 값비싼 네트워크 대역폭을 잡아먹고, 전송을 느리게 만들며, 웹 서버에 부하를 준다. 캐시를 이용하면 첫 번째 서버 응답은 캐시에 보관된다. 캐시된 사본이 뒤이은 요청들에 대한 응답으로 사용될 수 있기 때문에, 원 서버가 중복해서 트래픽을 주고받는 낭비가 줄어든다.



### 7.2 대역폭 병목

캐시는 네트워크 병목을 줄여준다. 클라이언트가 서버에 접근하는 것이 아닌 빠른 LAN에 있는 캐시로부터 사본을 가져온다면 캐싱은 성능을 대폭 개선할 수 있다.



### 7.3 갑작스런 요청 쇄도(Flash Crowds)

갑작스런 요청 쇄도 시에 불필요한 트래픽 급증은 네트워크와 웹 서버의 심각한 장애를 야기한다. 이에 대처하기 위해 캐싱은 중요하다.



### 7.4 거리로 인한 지연

대역폭이 문제가 되지 않더라도 거리가 문제가 될 수 있다. 캐시를 이용해서 문서가 전송되는 거리를 수천 킬로미터에서 수십 미터로 줄일 수 있다.



### 7.5 적중과 부적중

캐시는 유용하지만 캐시가 세상 모든 문서의 사본을 저장하지는 않는다. 캐시에 요청이 도착했을 때, 그에 대응하는 사본이 있다면 이를 이용해 요청이 처리될 수 있고 이를 `cache hit`(캐시 적중)이라고 부른다. 대응되는 사본이 없다면 원 서버로 전달된다. 이를 `cache miss`(캐시 부적중)라고 한다.

#### 7.5.1 재검사

원 서버 콘텐츠가 변경될 수 있기 때문에 캐시는 그들이 갖고 있는 사본이 최신인지 서버를 통해 때때로 점검해야 한다. 캐시는 스스로 원한다면 언제든지 사본을 재검사할 수 있다. 캐시가 문서를 굉장히 많이 갖고 있는 데 비해 네트워크 대역폭은 부족해서 대부분의 캐시는 클라이언트가 사본을 요청하였으며 그 사본이 검사를 할 필요가 있을 정도로 충분히 오래된 경우에만 재검사를 한다. 콘텐츠가 변경되지 않았다면 서버는 아주 작은 304 Not modified 응답을 보낸다. 사본이 여전히 유효함을 알게 된 캐시는 사본이 최신임을 표시한 후 클라이언트에 제공한다. 이를 재검사 적중 또는 느린 적중이라고 부르는데. 그래도 데이터를 서버로부터 받아오지 않기 때문에 cache miss보다는 빠르다.

##### 재검사 적중

객체가 변경되지 않았다면 서버는 클라이언트에게 작은 `HTTP 304 Not Modified` 응답을 보낸다.

##### 재검사 부적중

객체가 캐시된 사본과 다르다면 서버는 콘텐츠 전체와 함께 `HTTP 200 OK` 응답을 클라이언트에게 보낸다.

##### 객체 삭제

객체가 삭제되었다면 서버는 `404 Not Found` 응답을 돌려 보내고 캐시는 사본을 삭제한다.

#### 7.5.2 적중률

캐시 적중률은 캐시가 요청을 처리하는 비율을 말한다. 적중률을 예측하는 것은 어렵지만 적중률 40% 정도일 때 괜찮다고 한다.

#### 7.5.3 바이트 적중률

문서들이 모두 크기가 다르기 때문에 문서 적중률이 모든 것을 말해주지 않는다. 몇몇 큰 객체는 덜 접근되더라도 그 크기 때문에 전체 트래픽에 더 크게 기여하는 경우도 있다. 바이트 단위 적중률은 캐시를 통해 제공된 모든 바이트의 비율을 표현한다. 바이트 단위 적중률의 개선은 대역폭 절약을 최적화하고 문서 적중률의 개선은 전체 대기시간이 줄어든다.

#### 7.5.4 적중과 부적중의 구별

클라이언트는 응답이 캐시에서 온 것인지 원 서버에서 온 것인지 HTTP 응답을 통해 알 수 없다. 클라이언트는 date 헤더를 이용해서 응답의 생성일이 더 오래되었다면 응답이 캐시된 것임을 알아낼 수 있다.



### 7.6 캐시 토폴로지

#### 7.6.1 개인 전용 캐시

많은 에너지나 저장 공간을 필요로 하지 않으므로 작고 저렴할 수 있다. 웹 브라우저는 개인 전용 캐시를 내장하고 있다.

#### 7.6.2 공용 프락시 캐시

공용 캐시는 캐시 프락시 서버 혹은 더 흔히 프락시 캐시라고 불리는 특별한 종류의 공유된 프락시 서버다. 프락시 캐시는 6장에서 서술된 프락시를 위한 규칙에 따른다. 

#### 7.6.3 프락시 캐시 계층들

두 단계로 나누어 캐시 계층을 만드는 방식이 합리적일 수 있다. 클라이언트 주위에는 작고 저렴한 캐시를 사용하고 게층 상단에는 많은 사용자들에 의해 공유되는 문서를 유지하기 위해 더 크고 강력한 캐시를 사용하는 것이다. 캐시 계층이 깊다면 요청은 캐시의 긴 연쇄를 따라가게 된다. 프락시 연쇄가 길어질수록 각 중간 프락시는 성능 저하가 발생할 것이다.

#### 7.6.4 캐시망, 콘텐츠 라우팅, 피어링

몇몇 네트워크 아키텍처는 단순한 캐시 게층 대신 복잡한 캐시망을 만든다. 이런 캐시망의 프락시 캐시는 복잡한 방법으로 서로 대화하여 어떤 부모 캐시와 대화할 것인지, 아니면 요청이 캐시를 완전히 우회해서 원 서버로 바로 가도록 할 것인지에 대한 캐시 커뮤니케이션 결정을 동적으로 내린다.

* URL에 근거하여, 부모 캐시와 원 서버 중 하나를 동적으로 선택한다.
* URL에 근거하여 특정 부모 캐시를 동적으로 선택한다.
* 부모 캐시에게 가기 전에, 캐시된 사본을 로컬에서 찾아본다.
* 다른 캐시들이 그들의 캐시된 콘텐츠에 부분적으로 접근할 수 있도록 허용하되, 그들의 캐시를 통한 인터넷 트랜짓은 허용하지 않는다.

선택적인 피어링을 지원하는 캐시는 형제 캐시라고 불린다.



### 7.7 캐시 처리 단계

웹 캐시의 기본적인 동작은 대개 단순하다.

1. 요청 받기 - 캐시는 네트워크로부터 도착한 요청 메시지를 읽는다.
2. 파싱 - 캐시는 메시지를 파싱해서 URL과 헤더를 추출한다.
3. 검색 - 캐시는 로컬 사본이 있는지 검사하고, 사본이 없다면 사본을 받아온다.
4. 신선도 검사 - 캐시는 캐시된 사본이 충분히 신선한지 검사하고, 신선하지 않다면 변경사항이 있는지 서버에게 물어본다.
5. 응답 생성 - 캐시는 새로운 헤더와 캐시된 본문으로 응답 메시지를 만든다.
6. 발송 - 캐시는 네트워크를 통해 응답을 클라이언트에게 돌려준다.
7. 로깅 - 선택적으로, 캐시는 로그 파일에 트랜잭션에 대해 서술한 로그 하나를 남긴다.



### 7.8 사본을 신선하게 유지하기

#### 7.8.1 문서 만료

HTTP는 `Cache-Control`과 `Expires`라는 헤더를 이용해서 원 서버가 각 문서에 유효기간을 붙일 수 있게 해준다. 캐시 문서가 만료되기 전에 캐시는 필요하다면 서버와의 접촉 없이 사본을 제공할 수 있다. 문서가 만료되면 캐시는 반드시 서버와 문서에 변경된 것이 있는지 검사해야 한다.

#### 7.8.2 유효기간과 나이

서버는 응답 본문과 함께하는 `HTTP/1.0+ Expires`나 `HTTP/1.1 Cache-Control: max-age` 응답 헤더를 이용해서 유효기간을 명시한다. 

#### 7.8.3 서버 재검사

* 재검사 결과 콘텐츠가 변경되었다면, 캐시는 그 문서의 새로운 사본을 가져와 오래된 데이터 대신 저장한 뒤 클라이언트에게도 보내준다.
* 재검사 결과 콘텐츠가 변경되지 않았다면, 캐시는 새 만료일을 포함한 새 헤더들만 가져와서 캐시 안의 헤더들을 갱신한다.

HTTP 프로토콜은 캐시가 다음 중 하나를 반환하는 적절한 행동을 할 것을 요구한다.

* '충분히 신선한' 캐시된 사본
* 원 서버와 재검사되었기 때문에, 충분히 신선하다고 확신할 수 있는 캐시된 사본
* 에러 메시지(재검사해야 하는 원 서버가 다운된 경우)
* 경고 메시지가 부착된 캐시된 사본(부정확하다면)

#### 7.8.4 조건부 메서드와의 재검사

조건부 GET은 GET 요청 메시지에 특별한 조건부 헤더를 추가함으로써 시작된다. 웹 서버는 조건이 참인 경우에만 객체를 반환한다. HTTP는 다섯 가지 조건부 요청 헤더를 정의하는데 그 중 둘은 캐시 재검사를 할 때 가장 유용한 `If-Modified-Since`와`If-None-Match`이다.

#### 7.8.5 If-Modified-Since: 날짜 재검사

* 만약 문서가 주어진 날짜 이후에 변경되었다면, If-Modified-Since 조건은 참이고, 따라서 GET 요청은 평범하게 성공한다. 새 문서가, 새로운 만료 날짜와 그 외 다른 정보들이 담긴 헤더들과 함께 캐시에게 반환된다.
* 주어진 날짜 이후에 변경되지 않았다면 조건은 거짓이고 서버는 `304 Not Modified` 응답을 클라이언트에게 돌려준다. 응답은 헤더들을 포함하지만, 원래 돌려줘야 할 것에서 갱신이 필요한 것만을 보내준다. 새 만료 날짜는 보통 보내주게 된다.

```
If-Modified-Since: <캐시된 마지막 수정일>
```

#### 7.8.6 If-None-Match: 엔터티 태그 재검사

변경 일시 재검사가 적절히 행해지기 어려운 상황들이 있다.

* 어떤 문서는 일정 시간 간격으로 다시 쓰여지지만 실제로는 같은 데이터를 포함하고 있다. 내용에는 아무런 변화가 없더라도 변경시각은 바뀔 수 있다.
* 어떤 문서들의 변경은 전 세계의 캐시들이 그 데이터를 다시 읽어들이기엔 사소한 것일 수도 있다.
* 어떤 서버들은 그들이 갖고 있는 페이지에 대한 최근 변경 일시를 정확하게 판별할 수 없다.
* 1초보다 작은 간격으로 갱신되는 문서를 제공하는 서버들에게는 변경일에 대한 1초의 정밀도는 충분하지 않을 수 있다.

이럴 경우 엔터티 태그를 이용할 수 있다. 캐시는 새 문서의 사본을 얻기 위해 `If-None-Match` 조건부 헤더를 사용할 수 있다.

#### 7.8.7 약한 검사기와 강한 검사기

서버는 때때로 모든 캐시된 사본을 무효화시키지 않고 문서를 살짝 고칠 수 있도록 허용하고 싶은 경우가 있다. HTTP/1.1은, 비록 콘텐츠가 조금 변경되었더라도 **그 정도면 같은 것**이라고 서버가 주장할 수 있도록 해주는 약한 검사기(weak validator)를 지원한다.

#### 7.8.8 언제 엔터티 태그를 사용하고 언제 Last-Modified 일시를 사용하는가

HTTP/1.1 클라이언트는 서버가 엔터티 태그를 반환했다면, 반드시 엔터티 태그 검사기를 사용해야 한다. 서버가 Last-Modified 값만을 반환했다면 클라이언트는 If-Modified-Since 검사를 사용할 수 있다. 만약 둘 다 사용 가능하다면 두 가지의 재검사 정책을 모두 사용해야 한다. 



### 7.9 캐시 제어

얼마나 오랫동안 캐시될 수 있게 할 것인지 서버가 설정할 수 있는 여러 방법. 우선 순위 순으로 보면

* Cache-Control; no-store - 캐시가 응답의 사본을 만드는 것을 금지한다.
* Cache-Control: no-cache - 로컬 캐시 저장소에 저장될 수 있지만 재검사하지 않고는 클라이언트로 제공될 수 없다. 
* Cache-Control: must-revalidate - 신선하지 않은 사본을 원 서버와 최초의 재검사 없이는 제공할 수 없다.
* Cache-Control: max-age - 신선하다고 간주되는 문서가 서버로부터 온 이후로 흐른 시간으로 초로 나타낸다.
* Expires - 실제 만료 날짜를 제공한다.
* 아무 만료 정보도 주지 않고, 캐시가 스스로 휴리스틱 방법으로 결정하게 할 수 있다.

문서 만료는 완벽한 시스템이 아니다는 점을 주의하자.



### 7.10 캐시 제어 설정

웹 서버들은 캐시 제어와 만료 HTTP 헤더들을 설정하는 서로 다른 메커니즘을 제공한다.

#### 7.10.1 아파치로 HTTP 헤더 제어하기

#### 7.10.2 HTTP-EQUIV를 통한 HTML 캐시 제어



### 7.11 자세한 알고리즘

#### 7.11.1 나이와 신선도 수명

#### 7.11.2 나이 게산

#### 7.11.3 완전한 나이 계산 알고리즘

####  7.11.4 신선도 수명 게산

#### 7.11.5 완전한 서버 신선도 알고리즘



### 7.12 캐시와 광고

캐시는 사용자를 도와 더 좋은 경험을 제공하고, 네트워크 사업자들이 트래픽을 줄일 수 있도록 도와준다.

#### 7.12.1 광고 회사의 딜레마

캐시는 원 서버가 실제 접근 횟수를 알 수 없게 숨길 수 있다. 만약 캐싱이 완벽하게 동작한다면 원 서버는 HTTP 접근을 전혀 수신하지 않게 된다. 만약 접근 횟수에 따라 돈을 벌고 있다면 이는 달갑지 않은 일일 것이다.

#### 7.12.2 퍼블리셔의 응답

오늘날 광고회사들은 캐시가 광고 시청 수를 가로채지 못하도록 모든 종류의 '캐시 무력화' 기법을 사용한다. 그들은 광고 CGI 게이트웨이를 통해 제공하고, 매 접근마다 광고 URL을 고쳐 쓴다. 한 가지 방법은 모든 접근에 대해 원 서버와 재검사하도록 캐시를 설정하는 것으로 이는 트랜잭션을 느리게 만든다.

#### 7.12.3 로그 마이그레이션

이상적인 해결책 하나는 서버로 요청이 가지 않도록 하는 것. 캐시는 모든 적중의 로그를 유지할 수 있지만 크기 때문에 옮기기 어렵다. 인증과 프라이버시 이슈도 있다.

#### 7.12.4 적중 측정과 사용량 제한

RFC 2227, "Simple Hit-Metering and usage-Limiting for HTTP"은 더 간단한 방법을 정의한다. HTTP에 때때로 특정 URL에 대한 캐시 적중 횟수를 정기적으로 서버에 돌려주는 Meter라고 하는 새 헤더를 하나 추가한다. 



### 7.13 추가 정보

* http://www.w3.org/Protocols/rfc2616/rfc2616.txt
* Web Caching (Duane Wessels)
* http://www.ietf.org/rfc/rfc3040.txt
* Web Proxy Servers (Ari Luotonen)
* http://www.ietf.org/rfc/rfc3143.txt
* http://www.squid-cache.org

