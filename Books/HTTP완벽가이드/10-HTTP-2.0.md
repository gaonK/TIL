# 10장 HTTP 2.0

http://tools.ietf.org/html/draft-ietf-httpbis-http2-08

## 10.1 HTTP/2.0의 등장 배경

HTTP/1.1의 메시지 포맷은 구현의 단순성과 접근성에 주안점을 두고 최적화되어 성능이 어느 정도 희생되었다.
커넥션 하나를 통해 요청 하나를 보내고 그에 대한 응답 하나를 받는 HTTP의 메시지 교환 방식은 단순했지만, 응답을 받아야만 그 다음 요청을 보낼 수 있어서 심각한 회전 지연(latency)를 일으켰다.
이 문제를 회피하기 위해 병렬 커넥션이나 파이프라인 커넥션이 도입되었지만 근본적인 해결책이 되지 못했다.

2009년 구글은 웹을 더 빠르게 하겠다는 목표 아래 SPDY 프로토콜을 내놓았다.
SPDY는 헤더를 압축해서 대역폭을 절약했고, 하나의 TCP 커넥션에 여러 요청을 동시에 보내 회전 지연을 줄이고, 클라이언트가 요청을 보내지 않아도 서버가 능동적으로 리소스를 푸시하는 기능을 갖췄다.
이는 회전 지연을 줄이기 위한 것이다.

2013년 기준, 여덟 번째 초안까지 나왔고, SPDY의 특징을 거의 그대로 유지하고 있다. 

## 10.2 개요

HTTP/2.0은 서버와 클라이언트 사이의 TCP 커넥션 위에서 동작한다. 이때 TCP 커넥션을 초기화하는 것은 클라이언트다.
HTTP/2.0의 요청과 응답은 길이가 정의된(최대 16383 바이트) 한 개 이상의 프레임에 담긴다. 이때 HTTP 헤더는 압축되어 다긴다.

프레임에 담긴 요청과 응답은 스트림을 통해 보내진다. 한 개의 스트림이 한 쌍의 요청과 응답을 처리한다.
하나의 커넥션 위에는 여러 개의 스트림이 동시에 만들어질 수 있다. 따라서 여러 개의 요청과 응답을 동시에 처리하는 것이 가능하다.
스트림에 대한 흐름 제어와 우선순위 부여 기능도 제공한다.

기존의 요청-응답과는 다른 새로운 상호작용 모델인 서버 푸시도 도입되었다.
서버는 클라이언트에게 필요하다고 생각되는 리소스라면 그에 대한 요청을 명시적으로 받지 않더라도 능동적으로 클라이언트에게 보내줄 수 있다.

기존 웹 애플리케이션들과의 호환성 유지를 위해 HTTP/2.0은 요청과 응답 메시지의 의미를 HTTP/1.1과 같도록 유지하고  있다.


## 10.3 HTTP/1.1과의 차이점

### 10.3.1 프레임

HTTP/2.0에서 모든 메시지는 프레임에 담겨 전송된다. 모든 프레임은 8바이트 크기의 헤더로 시작해서 최대 16383바이트 크기의 페이로드가 뒤이어 온다.

* R: 예약된 2비트 필드. 반드시 0이어야 하고 받는 쪽에서는 이 값을 무시해야 한다.
* 길이: 페이로드의 길이를 나타내는 14비트 무부호 정수(unsigned integer).
* 종류: 프레임의 종류.
* 플래그: 8비트 플래그. 플래그 값의 의미는 프레임의 종류에 따라 다르다.
* R: 예약된 1비트 필드. 위의 R과 마찬가지로 반드시 0이어야 하고 받는 쪽에선 값을 무시한다.
* 스트림 식별자: 31비트 스트림 식별자. 특별히 0은 커넥션 전체와 연관된 프레임을 의미한다.

HTTP/2.0은 총 10가지 프레임을 정의하고 있고, 페이로드 형식이나 내용은 프레임 종류에 따라 다르다.


### 10.3.2 스트림과 멀티플렉싱

스트림은 HTTP/2.0 커넥션을 통해 클라이언트와 서버 사이에서 교환되는 프레임들의 독립된 양방향 시퀀스다.
한 쌍의 HTTP 요청과 응답은 하나의 스트림을 통해 이루어진다. 

HTTP/1.1에서는 한 TCP 커넥션을 통해 요청을 보냈을 때 응답이 와야 해당 TCP 커넥션을 다시 이용할 수 있다.
이런 문제점(회전지연) 때문에 여러 개의 TCP 커넥션을 만들어서 동시에 여러 개의 요청을 보낸다.

HTTP/2.0에서는 하나의 커넥션에 여러 개의 스트림이 동시에 열릴 수 있다. 스트림은 우선순위를 가질 수도 있기 때문에 중요한 리소스를 요청하는 스트림에게 더 높은 우선순위를 부여할 수 있다.
모든 스트림은 31비트의 무부호 정수로 된 고유한 스트림을 갖는다. 클라이언트에 의해 초기화되면 홀수, 서버에 의해 초기화되면 짝수이다. 
서버와 클라이언트는 일방적으로 스트림을 만들기 때문에 TCP 패킷을 주고받느라 시간을 낭비하지 않는다.
HTTP/2.0 커넥션에선 한번 사용한 스트림 식별자를 다시 사용할 수 없다. 식별자 고갈 시에는 커넥션을 다시 맺으면 된다.


### 10.3.3 헤더 압축

요즘에는 헤더 크기가 회전 지연과 대역폭 양쪽에 실질적인 영향을 끼치게 되었다. 이를 개선하기 위해 HTTP 메시지 헤더를 압축해서 전송한다.
HPACK 명세에 정의된 압축 방법으로 압축한 후 '헤더 블록 조각'으로 쪼개져서 전송도니다. 이 조각들을 연결해서 압축을 푼다.


### 10.3.4 서버 푸시

HTTP/2.0은 서버가 하나의 요청에 대해 응답으로 여러 개의 리소스를 보낼 수 있게 해준다.
리소스를 푸시하려는 서버는 먼저 클라이언트에게 자원을 푸시할 것임을 PUSH_PROMISE 프레임을 보내서 미리 알려준다.
클라이언트는 푸시를 거절해서 스트림을 닫을 수도 있다. 스트림이 닫히기 전까지 클라이언트는 서버가 푸시하려고 하는 리소스를 요청하지 않는다.
사전에 PUSH_PROMISE 프레임을 먼저 보내서 서버가 푸시하려고 하는 자원을 클라이언트가 또 요청하지 않도록 한다.

* 서버 푸시를 사용하기로 했더라도, 중간의 프락시가 서버로부터 받은 추가 리소스를 전달하지 않을 수 있으며, 아무런 추가 리소스를 서버로부터 받지 않았음에도 클라이언트에게 추가 리소스를 전달할 수도 있다.
* 서버는 오직 안전하고, 캐시 가능하고, 본문을 포함하지 않은 요청에 대해서만 푸시 가능하다.
* 푸시할 리소스는 클라이언트가 명시적으로 보낸 요청과 연관된 것이어야 한다.
* 클라이언트는 반드시 서버가 푸시한 리소스를 동일 출처 정책(Same-origin policy)에 따라 검사해야 한다.
* 서버 푸시를 끄고 싶다면 SETTINGS_ENABLE_PUSH를 0으로 설정한다.


## 10.4 알려진 보안 이슈

### 10.4.1 중개자 캡슐화 공격(Intermediary Encapsulation Attacks)

HTTP/2.0 메시지를 중간의 프락시가 HTTP/1.1 메시지로 변환할 때 메시지 의미가 변질될 가능성이 있다.
HTTP/2.0은 헤더 필드의 이름과 값을 바이너리로 인코딩하는데 이는 헤더 필드로 어떤 문자열이든 사용할 수 있게 해준다.


### 10.4.2 긴 커넥션 유지로 인한 개인정보 누출 우려


## 10.5 추가 정보

* http://http2.github.io/http2-spec/
* http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-04

